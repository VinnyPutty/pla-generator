# Copyright 2019, Vinay Putreddi, All rights reserved.

# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.

import functools
import hashlib
import inspect
import os
import sys
import time
import timeit
import traceback
import types
import warnings

import math


# region FLAGS
ALLOW_UNIMPLEMENTED = True
LOGGING_ENABLED = False
CONVERT_DICT_FLAG = True
# endregion


# region Decorators

# FIXME prints in the inner function should not run at start time
def unimplemented(func, default_excepthook=sys.excepthook):

    class NotImplementedWarning(Warning):
        pass

    @functools.wraps(func)
    def unimplemented_warning(*args, **kwargs):
        warnings.warn_explicit(
            "Call to unimplemented function {}.".format(func.__name__),
            category=NotImplementedWarning,
            filename=func.__code__.co_filename,
            lineno=func.__code__.co_firstlineno + 1)

        return func(*args, **kwargs)

    @functools.wraps(func)
    def unimplemented_exception(*args, **kwargs):
        sys.excepthook = exception_handler
        custom_exception = NotImplementedError("Call to unimplemented function {}.".format(func.__name__))
        # sys.excepthook = default_excepthook
        raise custom_exception
        return lambda: None

    # return unimplemented_warning
    return unimplemented_warning if ALLOW_UNIMPLEMENTED else unimplemented_exception


@unimplemented
def timeit_(func):
    def timed(*args, **kw):
        ts = time.time()
        result = func(*args, **kw)
        te = time.time()
        if 'log_time' in kw:
            name = kw.get('log_name', func.__name__.upper())
            kw['log_time'][name] = int((te - ts) * 1000)
        else:
            time_unit = kw["time_unit"] if "time_unit" in kw else "ms"
            if time_unit == "ns":
                print('{0!r}: {1:02.2f} ns'.format(func.__name__, (te - ts)))
            elif time_unit == "ms":
                print('{0!r}: {1:02.2f} ms'.format(func.__name__, (te - ts) * 1000))
            else:
                print('{0!r}: {1:02.2f} s'.format(func.__name__, (te - ts) * 1000000))
            # print('{0!r}: {1:02.2f} ms'.format(method.__name__, (te - ts) * 1000))
        return result
    return timed


def wrapper(func, *args, **kwargs):
    def wrapped_func():
        return func(*args, **kwargs)
    return wrapped_func

# endregion


# region Internal Python Redefinitions
def exception_handler(got_exception_type, got_exception, got_traceback):
    listing = traceback.format_exception(got_exception_type, got_exception, got_traceback)
    # Removing the listing of statement raise (raise line).
    del listing[-2]
    filelist = ["org.python.pydev"] # avoiding the debugger modules.
    listing = [item for item in listing if len([f for f in filelist if f in item]) == 0]
    files = [line for line in listing if line.startswith("  File")]
    if len(files) == 1:
        # only one file, remove the header.
        del listing[0]
    print("".join(listing), file=sys.stderr)


# sys.excepthook = exception_handler
# endregion


# region Global constants
BLANK_LAYOUT_ENTRIES = {
    "signature": "(Lay File generated by pla-generator by Vinay Putreddi)\n",
    "array": "A  {0} {1} {2} {3};\n",
    "composite": "C \"{0}\" T {1},{2};\n",
    "2-pt-wire": "W 400 {0},{1} {2},{3};\n",
    "3-pt-wire": "W 400 {0},{1} {2},{3} {4},{5};\n",
    "contact": "B 200,200 {0},{1};\n",
    "label": "T 50 {0},{1} 0 FONTWIRE \"{2}\";\n"
}
# TODO give the magic numbers representing the size of the components some descriptive names
PLA_COMPONENT_ATTRIBUTES = {

}

# endregion


def load_cmos_layers(load_from_file=False):
    if load_from_file:
        cmos_layers_file = open("../../definitions/cmos_layers.lay", "r")
        cmos_layers = cmos_layers_file.read()[:-1]
        cmos_layers_file.close()
    else:
        cmos_layers = inspect.cleandoc(
            '''
            (Lay File generated by Layout)
            0 10000 ;
            L "Default" NONE 192 0 0 0 1 1 1 0 0 0 1200 100 5 100 0 0;
            L CWN NONE 128 128 128 1 1 1 1 0 1 0 1200 100 50 100 12 8;
            L CAN NONE 0 128 0 0 1 1 0 0 0 0 1200 100 50 400 0 0;
            L CAP NONE 255 255 0 0 1 1 0 0 1 0 1200 100 50 100 0 0;
            L CPG NONE 255 0 0 0 1 1 0 0 0 0 1200 100 50 200 0 0;
            L CM1 NONE 72 72 200 0 1 1 0 0 1 0 1200 100 50 100 1 0;
            L CCC NONE 64 0 64 0 1 1 0 0 1 0 1200 100 50 100 0 0;
            L CM2 NONE 255 170 170 1 1 1 0 0 0 0 1200 100 50 400 12 0;
            L CV1 NONE 255 255 255 0 1 1 0 0 1 0 1200 100 50 100 0 0;
            L CM3 NONE 128 255 255 0 1 1 0 0 1 0 1200 100 50 100 0 0;
            L CM4 NONE 160 0 0 0 1 1 0 0 1 0 1200 100 50 100 0 0;
            L CM5 NONE 128 255 128 0 1 1 0 0 1 0 1200 100 50 100 0 0;
            L CV2 NONE 244 213 255 0 1 1 0 0 1 0 1200 100 50 100 0 0;
            L CV3 NONE 138 21 255 0 1 1 0 0 1 0 1200 100 50 100 0 0;
            L CV4 NONE 21 21 255 0 1 1 0 0 1 0 1200 100 50 100 0 0;
            L XP NONE 255 255 213 1 0 1 0 0 1 0 1200 100 50 100 0 0;
            L COG NONE 255 0 128 0 1 1 0 0 1 0 1200 100 50 100 0 0;
            L BND NONE 255 128 0 1 0 1 0 0 1 0 100 100 50 100 0 0;
            L TXT NONE 0 255 255 0 1 1 0 0 0 0 50 100 50 100 0 0;
            '''
        ) + '\n'
    cmos_layers = cmos_layers[cmos_layers.index('\n') + 1:]
    return cmos_layers


# TODO move input file parsers to separate python module
# region Input File Parsers
# FIXME Determine if this input format is to be deprecated or converted to a code-key: outputs-tuple-value map
#   this needs to be done to avoid writing the same pla code multiple times
# TODO Implement dictionary input method
def load_pla_codes(load_from_file=None, code_key=False):
    if load_from_file:
        with open(load_from_file) as pla_codes_file:
            pla_codes = inspect.cleandoc(pla_codes_file.read())
    else:
        pla_codes_output_key = inspect.cleandoc(
            '''
            inputs:in
            outputs:out
            ---
            codes:
            out:0,1
            '''
        )
        pla_codes_code_key = inspect.cleandoc(
            '''
            inputs:in
            outputs:out
            ---
            codes:
            0:out
            1:out
            '''
        )
        pla_codes = pla_codes_code_key if code_key else pla_codes_output_key

    # TODO move '..' operator functionality to separate function
    #   '..' op definition:
    #   '..' op should allow for the definition of a sequence of inputs using only the starting
    #   and ending numbers, chars, etc.; we should try to infer the step and type of sequence from
    #   the given start and end to the sequence
    #   '..' op is allowed to be incorporated into any input in the comma-separated list, so the sequence
    #   will need to be expanded in place while extracting the inputs into a data struct
    #   enumerate_ accomplished the above, but...
    # FIXME there is likely a better way to do this with nested list comprehension, but spending a couple hours got me
    #   nowhere further than this; so, since it works, it'll be used for now
    def enumerate_(pla_xputs):
        pla_xputs_out = []

        def range_(start, stop):
            return range(start, stop + 1) if start < stop else reversed(range(stop, start + 1))

        for x in pla_xputs:
            if x.__contains__(".."):
                z = [list(range_(*(int(y) for y in x.split(".."))))]
                for a in z:
                    for b in a:
                        pla_xputs_out.append(str(b))
            else:
                pla_xputs_out.append(str(x))

        return tuple(pla_xputs_out)

    pla_index_outputs = pla_codes.index('outputs')
    pla_inputs = enumerate_(pla_codes[pla_codes.index(':', pla_codes.index("inputs")) + 1:
                                      pla_index_outputs - 1].split(','))
    # TODO Add pla_outputs parser to pla_xputs_parser function
    pla_outputs = enumerate_(pla_codes[pla_codes.index(':', pla_index_outputs) + 1:
                                       pla_codes.index('\n', pla_index_outputs)].split(','))
    # print(pla_inputs)
    # print(pla_outputs)

    # print(pla_codes)
    pla_codes = pla_codes[pla_codes.index('\n', pla_codes.index("codes")) + 1:].split('\n')
    # print(type(pla_codes))
    # print(pla_codes)

    input_count = len(pla_inputs)
    output_count = len(pla_outputs)

    (pla_codes_dict, code_count) = load_pla_codes_code_key(pla_codes, pla_outputs) if \
        code_key else load_pla_codes_output_key(pla_codes)


    # print(pla_codes_dict)

    return (pla_inputs, pla_outputs, pla_codes_dict, code_count, input_count, output_count)


def load_pla_codes_output_key(pla_codes):
    pla_codes_dict = {}
    code_count = 0
    line = ''
    for line in pla_codes:
        line = line.split(':')
        if line[1]:
            codes = tuple(dict.fromkeys(line[1].split(',')))
            pla_codes_dict[line[0]] = codes
            code_count += len(codes)
    return (pla_codes_dict, code_count)


@unimplemented
def load_pla_codes_code_key(pla_codes, pla_outputs, output_count):
    pla_codes_dict = {}
    code_count = 0

    for line in pla_codes:
        line = line.split(':')
        if line[1]:
            outputs = 0b0
            for output in line[1].split(','):
                outputs += 1 << output_count - (pla_outputs.index(output) + 1)
            pla_codes_dict[line[0]] = outputs
            code_count += 1
    return (pla_codes_dict, code_count)


def convert_output_key_to_code_key_dict(pla_codes_dict, pla_outputs, output_count=-1):
    code_key_dict = {}
    if output_count < 0:
        output_count = len(pla_codes_dict)
    for (output, pla_codes) in pla_codes_dict.items():
        for pla_code in pla_codes:
            code_key_dict[pla_code] = (1 << output_count - (pla_outputs.index(output) + 1)) + \
                                      (code_key_dict[pla_code] if code_key_dict.__contains__(pla_code) else 0)
    return code_key_dict


@unimplemented
def convert_code_key_to_output_key_dict(pla_codes_dict, pla_outputs, output_count=-1):
    pass


# endregion


# TODO Implement extraction of this information in load_definitions and pass it to generate_pla_components_layout
def load_definitions(load_from_file=False):
    success = True
    definitions = None
    if load_from_file:
        success = False
        while not success:
            if not os.path.isfile("../../definitions/compiled_definitions.lay"):
                return load_definitions(False)
            definitions_file = open("../../definitions/compiled_definitions.lay", "r")
            definitions = definitions_file.read()
            definitions_file.close()
            success = True
            break
    else:
        definitions = inspect.cleandoc(
            '''
            (Lay File generated by Layout)
            0 10000 ;
            L "Default" NONE 192 0 0 0 1 1 1 0 0 0 1200 100 5 100 0 0;
            L CWN NONE 128 128 128 1 1 1 1 0 1 0 1200 100 50 100 12 8;
            L CAN NONE 0 128 0 0 1 1 0 0 0 0 1200 100 50 400 0 0;
            L CAP NONE 255 255 0 0 1 1 0 0 1 0 1200 100 50 100 0 0;
            L CPG NONE 255 0 0 0 1 1 0 0 0 0 1200 100 50 200 0 0;
            L CM1 NONE 72 72 200 0 1 1 0 0 1 0 1200 100 50 100 1 0;
            L CCC NONE 64 0 64 0 1 1 0 0 1 0 1200 100 50 100 0 0;
            L CM2 NONE 255 170 170 1 1 1 0 0 0 0 1200 100 50 400 12 0;
            L CV1 NONE 255 255 255 0 1 1 0 0 1 0 1200 100 50 100 0 0;
            L CM3 NONE 128 255 255 0 1 1 0 0 1 0 1200 100 50 100 0 0;
            L CM4 NONE 160 0 0 0 1 1 0 0 1 0 1200 100 50 100 0 0;
            L CM5 NONE 128 255 128 0 1 1 0 0 1 0 1200 100 50 100 0 0;
            L CV2 NONE 244 213 255 0 1 1 0 0 1 0 1200 100 50 100 0 0;
            L CV3 NONE 138 21 255 0 1 1 0 0 1 0 1200 100 50 100 0 0;
            L CV4 NONE 21 21 255 0 1 1 0 0 1 0 1200 100 50 100 0 0;
            L XP NONE 255 255 213 1 0 1 0 0 1 0 1200 100 50 100 0 0;
            L COG NONE 255 0 128 0 1 1 0 0 1 0 1200 100 50 100 0 0;
            L BND NONE 255 128 0 1 0 1 0 0 1 0 100 100 50 100 0 0;
            L TXT NONE 0 255 255 0 1 1 0 0 0 0 50 100 50 100 0 0;
            DS "PLA_OrPullup";
            L "Default";
            L CWN;
            B 3200,2400 1150,1800;
            L CAN;
            B 400,400 1150,2400;
            L CAP;
            B 400,400 350,1400;
            B 400,400 1950,1400;
            B 300,600 1950,1900;
            B 300,600 350,1900;
            B 400,400 1950,2400;
            B 400,400 350,2400;
            L CPG;
            B 2300,400 1150,1900;
            B 400,400 1150,1500;
            L CM1;
            B 400,1600 350,800;
            B 400,1700 1150,850;
            B 400,1600 1950,800;
            B 2300,400 1150,2400;
            L CCC;
            B 200,200 1950,1400;
            B 200,200 350,1400;
            B 200,200 1150,1500;
            B 200,200 350,2400;
            B 200,200 1950,2400;
            B 200,200 1150,2400;
            L CM2;
            B 2300,400 1150,500;
            W 400 200,2400 2100,2400;
            L CV1;
            B 200,200 1150,500;
            B 200,200 1150,2400;
            L BND;
            B 2300,3000 1150,1500;
            DF;
            DS "PLA_input";
            L "Default";
            L CWN;
            B 2400,2500 -1000,-2450;
            L CAN;
            B 1200,450 -1000,-375;
            B 400,400 -1400,-3200;
            L CAP;
            B 100,0 -650,-400;
            B 1200,900 -1000,-2250;
            L CPG;
            B 200,1400 -200,-700;
            B 300,400 -450,-1200;
            B 400,400 -700,-3200;
            W 200 -1000,-100 -1000,-750 -1100,-850 -1100,-1550 -1000,-1650 -1000,-3300;
            L CM1;
            B 400,2500 -600,-1450;
            B 400,900 -1400,-650;
            B 400,1600 -1400,-2600;
            B 400,400 -700,-3200;
            B 400,400 -400,-1200;
            L CCC;
            B 200,200 -1400,-400;
            B 200,200 -600,-400;
            B 200,200 -400,-1200;
            B 200,200 -1400,-2000;
            B 200,200 -1400,-2500;
            B 200,200 -600,-2000;
            B 200,200 -600,-2500;
            B 200,200 -700,-3200;
            B 200,200 -1400,-3200;
            L CM2;
            W 400 -200,-900 -1400,-900;
            W 400 -1400,-2500 -200,-2500;
            B 400,400 -700,-3200;
            L CV1;
            B 200,200 -1400,-900;
            B 200,200 -1400,-2500;
            B 200,200 -700,-3200;
            L BND;
            B 1600,3700 -800,-1850;
            DF;
            DS "PLA_io_if";
            L "Default";
            L CWN;
            B 900,1900 450,-2750;
            L CAN;
            B 400,1200 400,-2700;
            L CAP;
            B 400,400 200,-400;
            L CM1;
            B 400,1600 400,-2500;
            B 900,400 450,-400;
            L CCC;
            B 200,200 400,-2300;
            B 200,200 400,-2700;
            B 200,200 400,-3100;
            B 200,200 200,-400;
            L CM2;
            W 400 700,-200 700,-900 200,-900;
            B 400,800 400,-2100;
            W 400 200,-2500 336,-2500 436,-2600 700,-2600;
            L CV1;
            B 200,200 400,-1900;
            B 200,200 700,-400;
            L BND;
            B 900,3700 450,-1850;
            DF;
            DS "PLA_orPlane";
            L "Default";
            L CAP;
            B 400,400 1150,1050;
            L CPG;
            B 2300,200 1150,1450;
            B 2300,200 1150,650;
            L CM1;
            B 400,2100 1950,1050;
            B 400,2100 1150,1050;
            B 400,2100 350,1050;
            L CCC;
            B 200,200 1150,1050;
            L BND;
            B 2300,2100 1150,1050;
            B 200,200 350,1050;
            B 200,200 1950,1050;
            B 200,100 1150,50;
            B 200,200 1150,200;
            B 200,200 1150,1900;
            B 200,100 1150,2050;
            DF;
            DS "PLA_ip_if";
            L "Default";
            L CAP;
            B 400,400 200,1050;
            L CPG;
            B 400,400 700,1750;
            B 400,400 700,350;
            B 200,200 800,1450;
            B 200,200 800,650;
            L CM1;
            B 900,400 450,1750;
            B 900,400 450,1050;
            B 900,400 450,350;
            L CCC;
            B 200,200 700,350;
            B 200,200 700,1750;
            B 200,200 200,1050;
            L CM2;
            W 400 700,1900 700,200;
            L CV1;
            B 200,200 700,1050;
            L BND;
            B 900,2100 450,1050;
            B 200,200 200,1750;
            B 200,200 200,350;
            DF;
            DS "PLA_andPlane";
            L "Default";
            L CAP;
            B 400,400 -1400,1050;
            L CPG;
            B 200,2100 -1000,1050;
            B 200,2100 -200,1050;
            L CM1;
            B 1600,400 -800,350;
            B 1600,400 -800,1050;
            B 1600,400 -800,1750;
            L CCC;
            B 200,200 -1400,1050;
            L BND;
            B 1600,2100 -800,1050;
            B 200,200 -1400,1750;
            B 200,200 -600,1050;
            B 200,200 -1400,350;
            DF;
            DS "PLA_pullup";
            L "Default";
            L CWN;
            B 2600,3000 -1900,1050;
            L CAN;
            B 400,400 -2400,1050;
            L CAP;
            B 400,400 -2400,350;
            B 400,400 -2400,1750;
            B 600,300 -1900,350;
            B 600,300 -1900,1750;
            B 400,400 -1400,1750;
            B 400,400 -1400,350;
            L CPG;
            B 400,400 -1500,1050;
            B 400,2100 -1900,1050;
            L CM1;
            B 400,2100 -2400,1050;
            B 1600,400 -800,1750;
            B 1700,400 -850,1050;
            B 1600,400 -800,350;
            L CCC;
            B 200,200 -2400,1050;
            B 200,200 -1500,1050;
            B 200,200 -2400,1750;
            B 200,200 -2400,350;
            B 200,200 -1400,350;
            B 200,200 -1400,1750;
            L CM2;
            B 400,2100 -2400,1050;
            L CV1;
            B 200,200 -2400,1050;
            L BND;
            B 3200,2100 -1600,1050;
            DF;
            DS "Pla_output";
            L "Default";
            L CWN;
            B 3200,2100 1150,-2850;
            L CAN;
            B 2000,450 1150,-975;
            L CAP;
            B 2000,900 1150,-2850;
            L CPG;
            B 400,400 450,-300;
            B 400,400 1850,-300;
            B 200,3400 750,-1800;
            B 200,3400 1550,-1800;
            L CM1;
            B 400,2900 350,-2250;
            B 400,2900 1950,-2250;
            B 400,1500 1150,-2550;
            B 400,500 1950,-250;
            B 400,1200 1150,-600;
            B 400,500 350,-250;
            B 100,400 600,-300;
            B 100,400 1700,-300;
            L CCC;
            B 200,200 450,-300;
            B 200,200 1850,-300;
            B 200,200 1150,-1000;
            B 200,200 1950,-1000;
            B 200,200 350,-1000;
            B 200,200 350,-2600;
            B 200,200 350,-3100;
            B 200,200 1150,-2600;
            B 200,200 1950,-2600;
            B 200,200 1150,-3100;
            B 200,200 1950,-3100;
            L CM2;
            B 400,400 350,-3500;
            B 400,400 1950,-3500;
            W 400 1150,-2000 1150,-2300;
            W 400 200,-2600 2100,-2600;
            L CV1;
            B 200,200 350,-3500;
            B 200,200 1950,-3500;
            B 200,200 1150,-2000;
            L BND;
            B 2300,3700 1150,-1850;
            DF;
            E
            '''
        )

    definitions = definitions[definitions.index("DS"):-1]
    # print(definitions)
    # print(repr(definitions))

    return (success, definitions)


def generate_pla_components_layout(code_count, input_count, output_count):
    vert_count = math.ceil(code_count / 2)
    hor_count = math.ceil(output_count / 2)

    # FIXME these are currently magic definitions using magic numbers
    # TODO Implement extraction of this information in load_definitions and pass it to generate_pla_components_layout
    pla_components_dict = {
        "PLA_ip_if": (1, vert_count, 900, 2100, 1600 * (input_count - 1), 0),
        "PLA_orPlane": (hor_count, vert_count, 2300, 2100, 1600 * (input_count - 1) + 900, 0),
        "PLA_input": (input_count, 1, 1600, 3700, 0, 0),
        "PLA_andPlane": (input_count, vert_count, 1600, 2100, 0, 0),
        "PLA_pullup": (1, vert_count, 3200, 2100, -1600, 0),
        "PLA_OrPullup": (hor_count, 1, 2300, 3000, 1600 * (input_count - 1) + 900, 2100 * vert_count),
        "Pla_output": (hor_count, 1, 2300, 3700, 1600 * (input_count - 1) + 900, 0)
    }

    pla_components = ""

    pla_components += "L \"Default\";\n"
    for (component, params) in pla_components_dict.items():
        pla_components += BLANK_LAYOUT_ENTRIES["array"].format(params[0], params[1], params[2], params[3])
        pla_components += BLANK_LAYOUT_ENTRIES["composite"].format(component, params[4], params[5])
    pla_components += BLANK_LAYOUT_ENTRIES["composite"].format("PLA_io_if", 1600 * (input_count - 1), 0)

    return pla_components


# TODO move top level connections layout generation to separate python module
# region Top-level connections layout generation
# FIXME When load_pla_codes output-key: code-tuple-value map input format is deprecated or conversion is implemented,
#   this will needed to change to handle the new code-key: outputs-tuple-value map pla_codes_dict
# FIXME left_entry_output is redundant in this implementation of the algorithm because it always has the same value as
#   bottom_entry_code; however, it exists for clarity when reading the code
# FIXME Handling of pla_output:pla_codes key:value pair should be moved to separate function so code isn't repeated for
#   special handling of first and last code
def generate_pla_wires_layout(pla_codes_dict, input_count, output_count, code_count, code_key=False):
    output_wire_start_pos = (1600 * (input_count - 1) + 2050, 200)

    pla_codes_dict_list = [pla_output_codes for pla_output_codes in pla_codes_dict.items()]
    # print(pla_codes_dict_list)

    (pla_wires, contact_locs) = generate_pla_wires_layout_code_key(pla_codes_dict_list, output_wire_start_pos,
                                                                   output_count) if code_key \
        else generate_pla_wires_layout_output_key(pla_codes_dict_list, output_wire_start_pos)

    # region Compute CM2 wires
    vert_count = math.ceil(code_count / 2)
    pla_wires += "L CM2;\n"
    pla_wires += BLANK_LAYOUT_ENTRIES["3-pt-wire"].format(-4000, -200, -4000, -2500, -1800, -2500)
    pla_wires += BLANK_LAYOUT_ENTRIES["3-pt-wire"].format(-4000, 2100 * vert_count + 200, -4000,
                                                          2100 * vert_count + 2400, 1600 * (input_count - 1) + 700,
                                                          2100 * vert_count + 2400)
    pla_wires += BLANK_LAYOUT_ENTRIES["2-pt-wire"].format(1600 * (input_count - 1) + 700, 2100 * vert_count + 200,
                                                          1600 * (input_count - 1) + 700, 2100 * vert_count + 500)
    # endregion
    return (pla_wires, contact_locs)


# TODO use slicing of pla_codes of first and last output entry instead of bool first_pla_code
# TODO Verify functionality of above TODO
# FIXME broken in more ways than one
def generate_pla_wires_layout_output_key(pla_codes_dict_list, output_wire_start_pos):
    current_code_wire_pos = (-600, 1050)
    current_output_wire_pos = output_wire_start_pos
    bottom_entry_code = True
    left_entry_output = True
    pla_wires = "L CAN;\n"
    contact_locs = []

    @unimplemented
    def process_pla_code(pla_code_, curr_x_pos, curr_y_pos, pla_wires):
        y_pos_shift = -700 if bottom_entry_code else 700
        (curr_x_pos, curr_y_pos) = current_code_wire_pos
        for code_entry in list(pla_code):
            anchor_points = None
            if code_entry == '1':
                new_x_pos = curr_x_pos + 800
                new_y_pos = curr_y_pos + y_pos_shift
                anchor_points = (curr_x_pos, curr_y_pos, curr_x_pos, new_y_pos, new_x_pos, new_y_pos)
            elif code_entry == '0':
                new_x_pos = curr_x_pos - 800
                new_y_pos = curr_y_pos + y_pos_shift
                anchor_points = (curr_x_pos, curr_y_pos, curr_x_pos, new_y_pos, new_x_pos, new_y_pos)
            if anchor_points:
                # print(anchor_points)
                pla_wires += BLANK_LAYOUT_ENTRIES["3-pt-wire"].format(*anchor_points)
                if bottom_entry_code:
                    contact_locs.append((curr_x_pos, curr_y_pos))
                contact_locs.append((new_x_pos, new_y_pos))  # no it won't; this is fine
            curr_x_pos += 1600
        if not bottom_entry_code:
            current_code_wire_pos = (current_code_wire_pos[0], curr_y_pos + 2100)
        # endregion
        # region Output Wire Generation
        # anchor_points = None
        y_pos_shift = 850
        x_pos_shift = -800 if left_entry_output else 800
        (curr_x_pos, curr_y_pos) = current_output_wire_pos
        new_x_pos = curr_x_pos + x_pos_shift
        new_y_pos = curr_y_pos + y_pos_shift
        anchor_points = (curr_x_pos, curr_y_pos, new_x_pos, curr_y_pos, new_x_pos, new_y_pos)
        pla_wires += BLANK_LAYOUT_ENTRIES["3-pt-wire"].format(*anchor_points)
        contact_locs.append((curr_x_pos, curr_y_pos))
        contact_locs.append((new_x_pos, new_y_pos))
        # curr_x_pos += 2300 if not left_entry_output else 0
        curr_y_pos += 1900
        current_output_wire_pos = (curr_x_pos, curr_y_pos)
        # left_entry_output = not left_entry_output

    # region Special handling of output wires of first code
    (pla_output, pla_codes) = pla_codes_dict_list[0]
    print("Computing connections for output {}...".format(pla_output))
    for pla_code in pla_codes[:1]:
        # region Code Connection Computation
        y_pos_shift = -700 if bottom_entry_code else 700
        (curr_x_pos, curr_y_pos) = current_code_wire_pos
        for code_entry in list(pla_code):
            anchor_points = None
            if code_entry == '1':
                new_x_pos = curr_x_pos + 800
                new_y_pos = curr_y_pos + y_pos_shift
                anchor_points = (curr_x_pos, curr_y_pos, curr_x_pos, new_y_pos, new_x_pos, new_y_pos)
            elif code_entry == '0':
                new_x_pos = curr_x_pos - 800
                new_y_pos = curr_y_pos + y_pos_shift
                anchor_points = (curr_x_pos, curr_y_pos, curr_x_pos, new_y_pos, new_x_pos, new_y_pos)
            if anchor_points:
                # print(anchor_points)
                pla_wires += BLANK_LAYOUT_ENTRIES["3-pt-wire"].format(*anchor_points)
                if bottom_entry_code:
                    contact_locs.append((curr_x_pos, curr_y_pos))
                contact_locs.append((new_x_pos, new_y_pos))  # no it won't; this is fine
            curr_x_pos += 1600
        if not bottom_entry_code:
            current_code_wire_pos = (current_code_wire_pos[0], curr_y_pos + 2100)
        # endregion
        # region Output Wire Generation
        # anchor_points = None
        y_pos_shift = 850
        x_pos_shift = -800 if left_entry_output else 800
        (curr_x_pos, curr_y_pos) = current_output_wire_pos
        new_x_pos = curr_x_pos + x_pos_shift
        new_y_pos = curr_y_pos + y_pos_shift
        anchor_points = (curr_x_pos, curr_y_pos, new_x_pos, curr_y_pos, new_x_pos, new_y_pos)
        pla_wires += BLANK_LAYOUT_ENTRIES["3-pt-wire"].format(*anchor_points)
        contact_locs.append((curr_x_pos, curr_y_pos))
        contact_locs.append((new_x_pos, new_y_pos))
        # curr_x_pos += 2300 if not left_entry_output else 0
        curr_y_pos += 1900
        current_output_wire_pos = (curr_x_pos, curr_y_pos)
        # left_entry_output = not left_entry_output
        # endregion
        bottom_entry_code = not bottom_entry_code
    if len(pla_codes_dict_list) > 1:
        for pla_code in pla_codes[1:]:
            # region Code Connection Computation
            y_pos_shift = -700 if bottom_entry_code else 700
            (curr_x_pos, curr_y_pos) = current_code_wire_pos
            for code_entry in list(pla_code):
                anchor_points = None
                if code_entry == '1':
                    new_x_pos = curr_x_pos + 800
                    new_y_pos = curr_y_pos + y_pos_shift
                    anchor_points = (curr_x_pos, curr_y_pos, curr_x_pos, new_y_pos, new_x_pos, new_y_pos)
                elif code_entry == '0':
                    new_x_pos = curr_x_pos - 800
                    new_y_pos = curr_y_pos + y_pos_shift
                    anchor_points = (curr_x_pos, curr_y_pos, curr_x_pos, new_y_pos, new_x_pos, new_y_pos)
                if anchor_points:
                    # print(anchor_points)
                    pla_wires += BLANK_LAYOUT_ENTRIES["3-pt-wire"].format(*anchor_points)
                    if bottom_entry_code:
                        contact_locs.append((curr_x_pos, curr_y_pos))
                    contact_locs.append((new_x_pos, new_y_pos))  # no it won't; this is fine
                curr_x_pos += 1600
            if not bottom_entry_code:
                current_code_wire_pos = (current_code_wire_pos[0], curr_y_pos + 2100)
            # endregion
            # region Output Wire Generation
            # anchor_points = None
            y_pos_shift = 1050 if bottom_entry_code else -1050
            x_pos_shift = -800 if left_entry_output else 800
            (curr_x_pos, curr_y_pos) = current_output_wire_pos
            new_x_pos = curr_x_pos + x_pos_shift
            new_y_pos = curr_y_pos + y_pos_shift
            anchor_points = (curr_x_pos, curr_y_pos, new_x_pos, curr_y_pos, new_x_pos, new_y_pos)
            pla_wires += BLANK_LAYOUT_ENTRIES["3-pt-wire"].format(*anchor_points)
            contact_locs.append((curr_x_pos, curr_y_pos))
            contact_locs.append((new_x_pos, new_y_pos))
            # curr_x_pos += 2300 if not left_entry_output else 0
            curr_y_pos += 2100 if bottom_entry_code else 0
            current_output_wire_pos = (curr_x_pos, curr_y_pos)
            # left_entry_output = not left_entry_output
            # endregion
            bottom_entry_code = not bottom_entry_code
        (curr_x_pos, curr_y_pos) = current_output_wire_pos
        curr_x_pos += 2300 if not left_entry_output else 0
        current_output_wire_pos = (curr_x_pos, curr_y_pos)
        left_entry_output = not left_entry_output
        # endregion
        for (pla_output, pla_codes) in pla_codes_dict_list[1:-1]:
            print("Computing connections for output {}...".format(pla_output))
            for pla_code in pla_codes:
                # region Code Connection Computation
                y_pos_shift = -700 if bottom_entry_code else 700
                (curr_x_pos, curr_y_pos) = current_code_wire_pos
                for code_entry in list(pla_code):
                    anchor_points = None
                    if code_entry == '1':
                        new_x_pos = curr_x_pos + 800
                        new_y_pos = curr_y_pos + y_pos_shift
                        anchor_points = (curr_x_pos, curr_y_pos, curr_x_pos, new_y_pos, new_x_pos, new_y_pos)
                    elif code_entry == '0':
                        new_x_pos = curr_x_pos - 800
                        new_y_pos = curr_y_pos + y_pos_shift
                        anchor_points = (curr_x_pos, curr_y_pos, curr_x_pos, new_y_pos, new_x_pos, new_y_pos)
                    if anchor_points:
                        # print(anchor_points)
                        pla_wires += BLANK_LAYOUT_ENTRIES["3-pt-wire"].format(*anchor_points)
                        if bottom_entry_code:
                            contact_locs.append((curr_x_pos, curr_y_pos))
                        contact_locs.append((new_x_pos, new_y_pos))  # no it won't; this is fine
                    curr_x_pos += 1600
                if not bottom_entry_code:
                    current_code_wire_pos = (current_code_wire_pos[0], curr_y_pos + 2100)
                # endregion
                # region Output Wire Generation
                # anchor_points = None
                y_pos_shift = 1050 if bottom_entry_code else -1050
                x_pos_shift = -800 if left_entry_output else 800
                (curr_x_pos, curr_y_pos) = current_output_wire_pos
                new_x_pos = curr_x_pos + x_pos_shift
                new_y_pos = curr_y_pos + y_pos_shift
                anchor_points = (curr_x_pos, curr_y_pos, new_x_pos, curr_y_pos, new_x_pos, new_y_pos)
                pla_wires += BLANK_LAYOUT_ENTRIES["3-pt-wire"].format(*anchor_points)
                contact_locs.append((curr_x_pos, curr_y_pos))
                contact_locs.append((new_x_pos, new_y_pos))
                # curr_x_pos += 2300 if not left_entry_output else 0
                curr_y_pos += 2100 if bottom_entry_code else 0
                current_output_wire_pos = (curr_x_pos, curr_y_pos)
                # left_entry_output = not left_entry_output
                # endregion
                bottom_entry_code = not bottom_entry_code
            (curr_x_pos, curr_y_pos) = current_output_wire_pos
            curr_x_pos += 2300 if not left_entry_output else 0
            current_output_wire_pos = (curr_x_pos, curr_y_pos)
            left_entry_output = not left_entry_output
        # region Special handling of output wires of last code
        (pla_output, pla_codes) = pla_codes_dict_list[-1]
        print("Computing connections for output {}...".format(pla_output))
        for pla_code in pla_codes[:-1]:
            # region Code Connection Computation
            y_pos_shift = -700 if bottom_entry_code else 700
            (curr_x_pos, curr_y_pos) = current_code_wire_pos
            for code_entry in list(pla_code):
                anchor_points = None
                if code_entry == '1':
                    new_x_pos = curr_x_pos + 800
                    new_y_pos = curr_y_pos + y_pos_shift
                    anchor_points = (curr_x_pos, curr_y_pos, curr_x_pos, new_y_pos, new_x_pos, new_y_pos)
                elif code_entry == '0':
                    new_x_pos = curr_x_pos - 800
                    new_y_pos = curr_y_pos + y_pos_shift
                    anchor_points = (curr_x_pos, curr_y_pos, curr_x_pos, new_y_pos, new_x_pos, new_y_pos)
                if anchor_points:
                    # print(anchor_points)
                    pla_wires += BLANK_LAYOUT_ENTRIES["3-pt-wire"].format(*anchor_points)
                    if bottom_entry_code:
                        contact_locs.append((curr_x_pos, curr_y_pos))
                    contact_locs.append((new_x_pos, new_y_pos))  # no it won't; this is fine
                curr_x_pos += 1600
            if not bottom_entry_code:
                current_code_wire_pos = (current_code_wire_pos[0], curr_y_pos + 2100)
            # endregion
            # region Output Wire Generation
            # anchor_points = None
            y_pos_shift = 1050 if bottom_entry_code else -1050
            x_pos_shift = -800 if left_entry_output else 800
            (curr_x_pos, curr_y_pos) = current_output_wire_pos
            new_x_pos = curr_x_pos + x_pos_shift
            new_y_pos = curr_y_pos + y_pos_shift
            anchor_points = (curr_x_pos, curr_y_pos, new_x_pos, curr_y_pos, new_x_pos, new_y_pos)
            pla_wires += BLANK_LAYOUT_ENTRIES["3-pt-wire"].format(*anchor_points)
            contact_locs.append((curr_x_pos, curr_y_pos))
            contact_locs.append((new_x_pos, new_y_pos))
            # curr_x_pos += 2300 if not left_entry_output else 0
            curr_y_pos += 2100 if bottom_entry_code else 0
            current_output_wire_pos = (curr_x_pos, curr_y_pos)
            # left_entry_output = not left_entry_output
            # endregion
            bottom_entry_code = not bottom_entry_code
        for pla_code in pla_codes[-1:]:
            # region Code Connection Computation
            y_pos_shift = -700 if bottom_entry_code else 700
            (curr_x_pos, curr_y_pos) = current_code_wire_pos
            for code_entry in list(pla_code):
                anchor_points = None
                if code_entry == '1':
                    new_x_pos = curr_x_pos + 800
                    new_y_pos = curr_y_pos + y_pos_shift
                    anchor_points = (curr_x_pos, curr_y_pos, curr_x_pos, new_y_pos, new_x_pos, new_y_pos)
                elif code_entry == '0':
                    new_x_pos = curr_x_pos - 800
                    new_y_pos = curr_y_pos + y_pos_shift
                    anchor_points = (curr_x_pos, curr_y_pos, curr_x_pos, new_y_pos, new_x_pos, new_y_pos)
                if anchor_points:
                    # print(anchor_points)
                    pla_wires += BLANK_LAYOUT_ENTRIES["3-pt-wire"].format(*anchor_points)
                    if bottom_entry_code:
                        contact_locs.append((curr_x_pos, curr_y_pos))
                    contact_locs.append((new_x_pos, new_y_pos))  # no it won't; this is fine
                curr_x_pos += 1600
            if not bottom_entry_code:
                current_code_wire_pos = (current_code_wire_pos[0], curr_y_pos + 2100)
            # endregion
            # region Output Wire Generation
            # anchor_points = None
            y_pos_shift = 1050 if bottom_entry_code else -850
            x_pos_shift = -800 if left_entry_output else 800
            (curr_x_pos, curr_y_pos) = current_output_wire_pos
            curr_y_pos -= (200 if not bottom_entry_code else 0)
            new_x_pos = curr_x_pos + x_pos_shift
            new_y_pos = curr_y_pos + y_pos_shift
            anchor_points = (curr_x_pos, curr_y_pos, new_x_pos, curr_y_pos, new_x_pos, new_y_pos)
            pla_wires += BLANK_LAYOUT_ENTRIES["3-pt-wire"].format(*anchor_points)
            contact_locs.append((curr_x_pos, curr_y_pos))
            contact_locs.append((new_x_pos, new_y_pos))
            # curr_x_pos += 2300 if not left_entry_output else 0
            curr_y_pos += 2100 if bottom_entry_code else 0
            current_output_wire_pos = (curr_x_pos, curr_y_pos)
            # left_entry_output = not left_entry_output
            # endregion
            bottom_entry_code = not bottom_entry_code
        (curr_x_pos, curr_y_pos) = current_output_wire_pos
        curr_x_pos += 2300 if not left_entry_output else 0
        current_output_wire_pos = (curr_x_pos, curr_y_pos)
        left_entry_output = not left_entry_output
        # endregion
    else:
        for pla_code in pla_codes[1:-1]:
            # region Code Connection Computation
            y_pos_shift = -700 if bottom_entry_code else 700
            (curr_x_pos, curr_y_pos) = current_code_wire_pos
            for code_entry in list(pla_code):
                anchor_points = None
                if code_entry == '1':
                    new_x_pos = curr_x_pos + 800
                    new_y_pos = curr_y_pos + y_pos_shift
                    anchor_points = (curr_x_pos, curr_y_pos, curr_x_pos, new_y_pos, new_x_pos, new_y_pos)
                elif code_entry == '0':
                    new_x_pos = curr_x_pos - 800
                    new_y_pos = curr_y_pos + y_pos_shift
                    anchor_points = (curr_x_pos, curr_y_pos, curr_x_pos, new_y_pos, new_x_pos, new_y_pos)
                if anchor_points:
                    # print(anchor_points)
                    pla_wires += BLANK_LAYOUT_ENTRIES["3-pt-wire"].format(*anchor_points)
                    if bottom_entry_code:
                        contact_locs.append((curr_x_pos, curr_y_pos))
                    contact_locs.append((new_x_pos, new_y_pos))  # no it won't; this is fine
                curr_x_pos += 1600
            if not bottom_entry_code:
                current_code_wire_pos = (current_code_wire_pos[0], curr_y_pos + 2100)
            # endregion
            # region Output Wire Generation
            # anchor_points = None
            y_pos_shift = 1050 if bottom_entry_code else -1050
            x_pos_shift = -800 if left_entry_output else 800
            (curr_x_pos, curr_y_pos) = current_output_wire_pos
            new_x_pos = curr_x_pos + x_pos_shift
            new_y_pos = curr_y_pos + y_pos_shift
            anchor_points = (curr_x_pos, curr_y_pos, new_x_pos, curr_y_pos, new_x_pos, new_y_pos)
            pla_wires += BLANK_LAYOUT_ENTRIES["3-pt-wire"].format(*anchor_points)
            contact_locs.append((curr_x_pos, curr_y_pos))
            contact_locs.append((new_x_pos, new_y_pos))
            # curr_x_pos += 2300 if not left_entry_output else 0
            curr_y_pos += 2100 if bottom_entry_code else 0
            current_output_wire_pos = (curr_x_pos, curr_y_pos)
            # left_entry_output = not left_entry_output
            # endregion
            bottom_entry_code = not bottom_entry_code
        for pla_code in pla_codes[-1:]:
            # region Code Connection Computation
            y_pos_shift = -700 if bottom_entry_code else 700
            (curr_x_pos, curr_y_pos) = current_code_wire_pos
            for code_entry in list(pla_code):
                anchor_points = None
                if code_entry == '1':
                    new_x_pos = curr_x_pos + 800
                    new_y_pos = curr_y_pos + y_pos_shift
                    anchor_points = (curr_x_pos, curr_y_pos, curr_x_pos, new_y_pos, new_x_pos, new_y_pos)
                elif code_entry == '0':
                    new_x_pos = curr_x_pos - 800
                    new_y_pos = curr_y_pos + y_pos_shift
                    anchor_points = (curr_x_pos, curr_y_pos, curr_x_pos, new_y_pos, new_x_pos, new_y_pos)
                if anchor_points:
                    # print(anchor_points)
                    pla_wires += BLANK_LAYOUT_ENTRIES["3-pt-wire"].format(*anchor_points)
                    if bottom_entry_code:
                        contact_locs.append((curr_x_pos, curr_y_pos))
                    contact_locs.append((new_x_pos, new_y_pos))  # no it won't; this is fine
                curr_x_pos += 1600
            if not bottom_entry_code:
                current_code_wire_pos = (current_code_wire_pos[0], curr_y_pos + 2100)
            # endregion
            # region Output Wire Generation
            # anchor_points = None
            y_pos_shift = 1050 if bottom_entry_code else -850
            x_pos_shift = -800 if left_entry_output else 800
            (curr_x_pos, curr_y_pos) = current_output_wire_pos
            curr_y_pos -= (200 if not bottom_entry_code else 0)
            new_x_pos = curr_x_pos + x_pos_shift
            new_y_pos = curr_y_pos + y_pos_shift
            anchor_points = (curr_x_pos, curr_y_pos, new_x_pos, curr_y_pos, new_x_pos, new_y_pos)
            pla_wires += BLANK_LAYOUT_ENTRIES["3-pt-wire"].format(*anchor_points)
            contact_locs.append((curr_x_pos, curr_y_pos))
            contact_locs.append((new_x_pos, new_y_pos))
            # curr_x_pos += 2300 if not left_entry_output else 0
            curr_y_pos += 2100 if bottom_entry_code else 0
            current_output_wire_pos = (curr_x_pos, curr_y_pos)
            # left_entry_output = not left_entry_output
            # endregion
            bottom_entry_code = not bottom_entry_code
        (curr_x_pos, curr_y_pos) = current_output_wire_pos
        curr_x_pos += 2300 if not left_entry_output else 0
        current_output_wire_pos = (curr_x_pos, curr_y_pos)
        left_entry_output = not left_entry_output
    return (pla_wires, contact_locs)


# FIXME? str traversal only benchmarked 3x as fast as bit manipulation when minimal string slicing and concantenating
#   is required
def generate_pla_wires_layout_code_key(pla_codes_dict_list, output_wire_start_pos, output_count):
    current_code_wire_pos = (-600, 1050)
    current_output_wire_pos = (output_wire_start_pos[0], output_wire_start_pos[1] - 200)
    bottom_entry_code = True
    left_entry_output = True
    pla_wires = "L CAN;\n"
    contact_locs = []
    # curr_x_pos, curr_y_pos, x_pos_shift, y_pos_shift, new_x_pos, new_y_pos, code_entry, anchor_points, pla_output, \
    #     output_start_shift

    def process_pla_code(output_y_shift):
        nonlocal current_code_wire_pos, current_output_wire_pos, bottom_entry_code, left_entry_output, pla_wires, \
            contact_locs, pla_outputs

        # nonlocal current_code_wire_pos, current_output_wire_pos, curr_x_pos, curr_y_pos, x_pos_shift, y_pos_shift, \
        #     new_x_pos, new_y_pos, code_entry, bottom_entry_code, left_entry_output, anchor_points, pla_wires, \
        #     contact_locs, pla_outputs, pla_output, output_start_shift

        print("Computing connections for code {}: {}".format(pla_code, bin(pla_outputs)[2:]))

        # region Code Connection Computation
        y_pos_shift = -700 if bottom_entry_code else 700
        (curr_x_pos, curr_y_pos) = current_code_wire_pos
        for code_entry in list(pla_code):
            anchor_points = None
            if code_entry == '1':
                new_x_pos = curr_x_pos + 800
                new_y_pos = curr_y_pos + y_pos_shift
                anchor_points = (curr_x_pos, curr_y_pos, curr_x_pos, new_y_pos, new_x_pos, new_y_pos)
            elif code_entry == '0':
                new_x_pos = curr_x_pos - 800
                new_y_pos = curr_y_pos + y_pos_shift
                anchor_points = (curr_x_pos, curr_y_pos, curr_x_pos, new_y_pos, new_x_pos, new_y_pos)
            if anchor_points:
                # print(anchor_points)
                pla_wires += BLANK_LAYOUT_ENTRIES["3-pt-wire"].format(*anchor_points)
                if bottom_entry_code:
                    contact_locs.append((curr_x_pos, curr_y_pos))
                contact_locs.append((new_x_pos, new_y_pos))  # no it won't; this is fine
            curr_x_pos += 1600
        if not bottom_entry_code:
            current_code_wire_pos = (current_code_wire_pos[0], curr_y_pos + 2100)
        # endregion
        # region Output Wire Generation
        left_entry_output = True
        (curr_x_pos, curr_y_pos) = current_output_wire_pos
        pla_outputs = bin(pla_outputs)[2:]
        output_x_start_shift = output_count - len(pla_outputs)
        left_entry_output = False if output_x_start_shift % 2 else True
        curr_x_pos += math.floor(output_x_start_shift / 2) * 2300
        for pla_output in pla_outputs:
            if int(pla_output):
                # anchor_points = None
                y_pos_shift = output_y_shift if bottom_entry_code else -output_y_shift
                x_pos_shift = -800 if left_entry_output else 800
                # (curr_x_pos, curr_y_pos) = current_output_wire_pos
                new_x_pos = curr_x_pos + x_pos_shift
                new_y_pos = curr_y_pos + y_pos_shift
                anchor_points = (curr_x_pos, curr_y_pos, new_x_pos, curr_y_pos, new_x_pos, new_y_pos)
                pla_wires += BLANK_LAYOUT_ENTRIES["3-pt-wire"].format(*anchor_points)
                contact_locs.append((curr_x_pos, curr_y_pos))
                contact_locs.append((new_x_pos, new_y_pos))
            curr_x_pos += 2300 if not left_entry_output else 0
            # current_output_wire_pos = (curr_x_pos, curr_y_pos)
            left_entry_output = not left_entry_output
        # endregion
        (curr_x_pos, curr_y_pos) = current_output_wire_pos
        curr_y_pos += 2100 if bottom_entry_code else 0
        current_output_wire_pos = (curr_x_pos, curr_y_pos)
        bottom_entry_code = not bottom_entry_code

    # print(pla_codes_dict_list)
    print(pla_codes_dict_list[0])
    current_output_wire_pos = (
        current_output_wire_pos[0], current_output_wire_pos[1] + 200)  # y axis offset bottom output line
    for (pla_code, pla_outputs) in pla_codes_dict_list[:1]:
        process_pla_code(output_y_shift=850)
    if len(pla_codes_dict_list) > 1:
        current_output_wire_pos = (
            current_output_wire_pos[0], current_output_wire_pos[1] - 200)  # compensate for offset of bottom output line
        for (pla_code, pla_outputs) in pla_codes_dict_list[1:-1]:
            process_pla_code(output_y_shift=1050)
        if not bottom_entry_code:
            current_output_wire_pos = (
                current_output_wire_pos[0], current_output_wire_pos[1] - 200)  # y axis offset top output line if needed
        for (pla_code, pla_outputs) in pla_codes_dict_list[-1:]:
            process_pla_code(output_y_shift=850)
    # else:

    # print(pla_wires)
    # print(contact_locs)
    return (pla_wires, contact_locs)


# Implementation currently depends on functionality in generate_pla_wires_layout; this is fine, as currently it is never
#   expected that contacts will not align with the wires
def generate_pla_contacts_layout(contact_locs):
    pla_contacts = "L CCC;\n"
    locs_per_tuple = len(contact_locs[0]) / 2
    if locs_per_tuple == 1:
        print("Generating {} contacts...".format(len(contact_locs)), end='')
        for x_pos, y_pos in contact_locs:
            # print('.', end='')
            pla_contacts += BLANK_LAYOUT_ENTRIES["contact"].format(x_pos, y_pos)
    elif locs_per_tuple == 3:
        print("Generating {} contacts...".format(len(contact_locs) * 2), end='')
        for x_pos, y_pos, x2_pos, y2_pos, x3_pos, y3_pos in contact_locs:
            # print('.', end='')
            pla_contacts += BLANK_LAYOUT_ENTRIES["contact"].format(x_pos, y_pos)
            pla_contacts += BLANK_LAYOUT_ENTRIES["contact"].format(x3_pos, y3_pos)
    print()
    return pla_contacts


# endregion


# TODO add Vdd and Gnd label generation functionality
# TODO move xput labels below the components
# TODO add pla code minterm label generation functionality (should be switchable and default off)
def generate_pla_labels_layout(pla_inputs, pla_outputs):
    pla_labels = "L TXT;\n"
    current_label_pos = -1200
    left_output_label = True
    for (pla_input) in pla_inputs:
        pla_labels += BLANK_LAYOUT_ENTRIES["label"].format(current_label_pos, -3000, pla_input)
        current_label_pos += 1600
    current_label_pos += 1050
    for (pla_output) in pla_outputs:
        if left_output_label:
            pla_labels += BLANK_LAYOUT_ENTRIES["label"].format(current_label_pos, -3500, pla_output)
            current_label_pos += 800
        else:
            pla_labels += BLANK_LAYOUT_ENTRIES["label"].format(current_label_pos, -3100, pla_output)
            current_label_pos += 1500
        left_output_label = not left_output_label
    return pla_labels


def write_output_to_file(pla_layout_output, input_filename=None):
    output_file_number = 0
    output_folder = "../../pla_layout/"
    output_file_name = (input_filename[input_filename.rfind('/') + 1:input_filename.rfind("pla_codes")] if
                        input_filename else "") + "pla_layout_output_{}.lay"
    if not os.path.isdir(output_folder):
        os.mkdir(output_folder)
    while os.path.isfile("{0}{1}".format(output_folder, output_file_name.format(output_file_number))):
        output_file_number += 1
    # print("Writing PLA layout to {0}{1}".format(output_folder, output_file_name.format(output_file_number)))
    output_file = open("{0}{1}".format(output_folder, output_file_name.format(output_file_number)), "w")
    output_file.write(pla_layout_output)
    output_file.close()

    print("PLA layout written to {0}{1}".format(output_folder, output_file_name.format(output_file_number)))


def generate_pla_layout(write_to_file=False, input_file=None):
    success = False
    pla_layout_output = None

    while not success:

        # region Load pre-defined layouts
        cmos_layers = load_cmos_layers(False)

        (success, pla_definitions) = load_definitions(False)
        if not success:
            break

        (pla_inputs, pla_outputs, pla_codes_dict, code_count, input_count, output_count) = load_pla_codes(input_file)
        # endregion

        # region Generate PLA layout per specifications in input file
        # pla_components = ""
        # pla_wires = ""
        # pla_contacts = ""
        # pla_labels = ""

        pla_components = generate_pla_components_layout(code_count, input_count, output_count)
        (pla_wires, contact_locs) = generate_pla_wires_layout(pla_codes_dict, input_count, code_count)
        pla_contacts = generate_pla_contacts_layout(contact_locs)
        pla_labels = generate_pla_labels_layout(pla_inputs, pla_outputs)
        # endregion

        # region Integrate loaded and generated layout components into one file openable in layout.exe
        pla_layout_output = BLANK_LAYOUT_ENTRIES["signature"]
        pla_layout_output += cmos_layers
        pla_layout_output += pla_definitions
        pla_layout_output += pla_components
        pla_layout_output += pla_wires
        pla_layout_output += pla_contacts
        pla_layout_output += pla_labels
        pla_layout_output += "E"
        # endregion

        # region Prints for console-based debugging
        print("\nPLA generation complete.")
        # print(pla_layout_output)
        # print(repr(pla_layout_output))
        print("input_count: {}\noutput_count: {}".format(input_count, output_count))
        # endregion

        if write_to_file:
            write_output_to_file(pla_layout_output, input_file)

        success = True
        break

    return (success, pla_layout_output)


if __name__ == '__main__':
    # load_definitions()
    # load_pla_codes(True)
    generate_pla_layout(True)
    # generate_pla_layout(True, "../../pla_codes/simple_pla_codes.pla")
    # generate_pla_layout(True, "../../pla_codes/4x4x16_pla_codes.pla")
    # generate_pla_layout(True, "../../pla_codes/31x31x31_pla_codes.pla")
    # generate_pla_layout(True, "../../pla_codes/32x32x32_pla_codes.pla")
    wrapped = wrapper(generate_pla_layout, True, "../../pla_codes/1024x1024x1024_pla_codes.pla")
    print(timeit.timeit(wrapped, number=1))  # this takes some time on redstone
    # generate_pla_layout(True, "../../pla_codes/1024x1024x4096_pla_codes.pla")  # this takes a long time on redstone
    # generate_pla_layout(True, "../../pla_codes/4096x4096x4096_pla_codes.pla")  # this takes forever on redstone; it
    # also requires about 6 GB of available memory

